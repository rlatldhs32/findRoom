# 워크 플로우 이름
name: Java CI with Gradle 


# 워크 플로우가 언제 실행 될지를 정한다.
on:
  push:
    branches: [ "dev" ]


jobs:
  backend-deploy:
    runs-on: ubuntu-latest
    steps:
      # SOURCE 단계 - 저장소 Checkout
      - name: Checkout-source code
        uses: actions/checkout@v3

      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'adopt'

      # Gradle 실행권한 부여
      - name: Grant execute permission to gradlew
        run: chmod +x ./gradlew



      # Spring boot application 빌드
      - name: Build with gradle
        run: ./gradlew clean build

      # docker image 빌드
      - name: Build docker image
        run: docker build -t sion/findRoom .

      # docker hub 로그인
      - name: Login docker hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # docker hub 퍼블리시
      - name: Publish to docker hub
        run: docker push sion/findRoom

      # WAS 인스턴스 접속 & 애플리케이션 실행
      - name: Connect to WAS & Execute Application
        uses: appleboy/ssh-action@v0.1.6
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
#          port: ${{ secrets.WAS_SSH_PORT }}
          script: |
            docker stop $(docker ps -a -q) 
            docker rm $(docker ps -a -q) 
            docker pull sion/findRoom
            docker run -d -p 8181:8181 --name findRoomContainer --network sionwork sion/findRoom







#
## 워크플로우에서 할 작업 정의한다.
#jobs:
#
#  # 작업 환경 = 우분투 최신 버전
#  build:
#    runs-on: ubuntu-latest
#
#    # 깃허브에서 제공하는 checkout 엑션 사용
#    steps:
#    - uses: actions/checkout@v3
#
#    # JDK 17 설정한당
#    # temurin = Adoptium에서 제공하는 JDK
#    - name: Set up JDK 17
#      uses: actions/setup-java@v3
#      with:
#        java-version: '17'
#        distribution: 'temurin'
#
#    # gradle wrapper 파일에 실행 권한을 부여
#    # gradle wrapper = 개발자가 특정 버전의 Gradle을 미리 설치하지 않고도 Gradle 빌드를 실행할 수 있게 해주는 편리한 도구
#    - name: Grant execute permission for gradlew
#      run: chmod +x gradlew
#
#    # Gradle 빌드 엑션을 이용해서 프로젝트 빌드
#    - name: Build with Gradle
#      uses: gradle/gradle-build-action@v2.6.0
#      with:
#        arguments: build
#
#    # 빌드해서 생긴 JAR 파일을 깃허브 아티팩트로 업로드!!
#    - name: Upload build artifact
#      uses: actions/upload-artifact@v2
#      with:
#        name: bestRoom
#        path: build/libs/bestRoom-0.0.1-SNAPSHOT.jar
#
#  # 배포 **
#  deploy:
#    needs: build
#    runs-on: ubuntu-latest
#
#    # 위의 빌드작업한 JAR 파일 = 아티팩트를 다운로드
#    steps:
#    - name: Download build artifact
#      uses: actions/download-artifact@v2
#      with:
#        name: bestRoom
#        path: build/libs/
#
#    # EC2에 배포
#    # EC2 SSH 키를 private_key.pem 파일로 저장 ( 위치는 GitHub 서버 )
#    # SCP를 사용하여 JAR 파일을 EC2 서버로 복사
#    # SSH를 사용하여 EC2 서버에 연결하고 현재 실행 중인 Java 프로세스를 종료한 다음 새로운 Java 프로세스 생성 및 실행!!
#    ## NLP 적용하면 IP -> 도메인으로 수정 + EC2 늘리면 run 추가
#    - name: Deploy to EC2
#      run: |
#        echo "${{ secrets.EC2_HOST }}"
#        echo "${{ secrets.EC2_USENAME }}"
#        echo "${{ secrets.EC2_SSH_KEY }}" > private_key.pem
#        chmod 600 private_key.pem
#        scp -i private_key.pem -o StrictHostKeyChecking=no build/libs/bestRoom-0.0.1-SNAPSHOT.jar ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }}:/home/${{ secrets.EC2_USERNAME }}/bestRoom.jar
#        ssh -i private_key.pem -o StrictHostKeyChecking=no ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} "pgrep java | xargs kill -9; nohup java -jar /home/${{ secrets.EC2_USERNAME }}/bestRoom.jar > app.log 2>&1 &"
#        rm -f private_key.pem
